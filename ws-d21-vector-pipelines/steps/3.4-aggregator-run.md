At this point we have sources and a sinkâ€”enough to have a valid pipeline that we can iterate on.
Let's start up our Aggregator.

```
make run-aggregator-scenario
```{{execute interrupt}}

## Monitoring Vector itself

With our Aggregator scenario running in the background, let's take a quick look at some tools that
often come in handy when running Vector in real environments: `vector tap` and `vector top`.

### vector tap

[`vector tap`][tap] enables you to pipe logs from a Vector instance into your local environment. It
communicates with Vector's [GraphQL] API.

```
vector tap
```{{execute T2}}

When run with no arguments, `vector tap` eavesdrops on *everything*, displaying all the logs flowing
through your Vector pipeline. But that's often a bit imprecise; it's usually more useful to target
a specific component. Let's try that with the `vector_agents` source:

```
vector tap vector_agents
```

### vector top

[`vector top`][top], not to be confused with `vector tap` from above, enables you to view Vector's
internal metrics in real time. It's inspired by a systems monitoring tool called [htop].

Run `vector top`{{execute T3}} to take a look. You'll see a per-component breakdown of how much
processing work different Vector components are doing in real time.

Both `tap` and `top` can be extremely useful in production environments. We'll use `tap` several
more times in this workshop to check on our pipeline and make sure that it's doing what we expect.

We won't use `top` again in this workshop but it's a good tool to keep in your back pocket.

[graphql]: https://graphql.org
[htop]: https://htop.dev
[tap]: https://vector.dev/docs/reference/cli/#tap
[top]: https://vector.dev/docs/reference/cli/#top
```
